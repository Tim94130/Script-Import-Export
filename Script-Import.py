# Importation des biblioth√®ques n√©cessaires
import pandas as pd
from tkinter import Tk, filedialog
import os
import re
import json
import unicodedata
from collections import defaultdict
from rapidfuzz import process, fuzz  # Si n√©cessaireimport csv
import csv
import MySQLdb


# D√©finitions globales pour la d√©tection des couleurs
adjectifs_ignores = [
    "dark", "light", "pale", "deep", "bright", "medium",
    "fonce", "fonc√©", "clair", "p√¢le", "flashy", "fluorescent"
]

couleurs_base = [
    "white", "black", "brown", "blue", "red", "pink", "green", 
    "grey", "gray", "yellow", "orange", "purple", "violet",
    "beige", "gold", "silver", "taupe", "cyan", "magenta",
    "navy", "maroon", "lime", "olive", "teal", "aqua",
    "blanc", "noir", "marron", "brun", "bleu", "rouge", "rose", 
    "vert", "gris", "jaune", "violet", "beige", "dor√©", "argent", "kaki",
    "turquoise", "fuchsia", "lavande", "ocre", "ivory", "ivoires", "argent√©",
    "rose gold", "off white", "peach pink", "sepia black", "golden",
    "sable", "chocolat", "prune" ,"dark brown"
]

mapping_couleurs = {
    "white": "Blanc",
    "off white": "Blanc cass√©",
    "ivory": "Blanc cass√©",
    "blanc": "Blanc",
    "dark brown": "Marron",
    "black": "Noir",
    "noir": "Noir",
    "sepia black": "Noir",
    
    "brown": "Marron",
    "brun": "Marron",
    "marron": "Marron",
    "chocolat": "Marron",
    
    "red": "Rouge",
    "rouge": "Rouge",
    
    "pink": "Rose",
    "rose": "Rose",
    "peach pink": "Rose",
    
    "green": "Vert",
    "vert": "Vert",
    "leaf green": "Vert",
    
    "grey": "Gris",
    "gray": "Gris",
    "gris": "Gris",
    "mirage grey": "Gris",
    
    "yellow": "Jaune",
    "jaune": "Jaune",
    
    "orange": "Orange",
    
    "purple": "Violet",
    "violet": "Violet",
    "lavande": "Violet",
    "prune": "Violet",
    
    "beige": "Beige",
    "sable": "Beige",
    "taupe": "Taupe",
    
    "gold": "Dor√©",
    "golden": "Dor√©",
    "rose gold": "Rose Gold",
    
    "silver": "Argent",
    "argent": "Argent",
    "argent√©": "Argent",
    
    "kaki": "Kaki",
    
    "fuchsia": "Fuchsia",
    "magenta": "Fuchsia",
    
    "blue": "Bleu",
    "bleu": "Bleu",
    "navy": "Bleu marine",
    "cyan": "Cyan",
    "aqua": "Cyan",
    "turquoise": "Turquoise",
    
    "maroon": "Bordeaux",
    "bordeaux": "Bordeaux",
    
    "lime": "Vert clair",
    "olive": "Vert olive",
    
    "teal": "Bleu-vert"
}



############################################
# Fonctions de transformation du CSV
############################################

def renommer_colonnes_pour_woocommerce(df):
    correspondance_woocommerce = {
        "R√©f√©rence": "SKU",
        "Nom de l'article (en Fran√ßais)": "Name",
        "Description courte (en Fran√ßais)": "Short description",
        "Description (en Fran√ßais)": "Description",
        "Prix pour le groupe D√©faut": "Regular price",
        "Stock - Quantit√©": "Stock",
        "Option Couleur (en Fran√ßais)": "Attribute 1 value(s)",
        "Option Taille (en Fran√ßais)": "Attribute 2 value(s)",
        "Poids (en Kg)": "Weight (kg)",
        "Longueur (en cm)": "Length (cm)",
        "Largeur (en cm)": "Width (cm)",
        "Hauteur (en cm)": "Height (cm)",
        "Cat√©gories": "Categories",
        "Parent": "Parent",
        "Images": "Images",
        "Garantie": "Warranty",
        "Pays de fabrication": "Country of manufacture",
        "Marque": "Brands"
    }
    df.rename(columns=correspondance_woocommerce, inplace=True)
    return df

def supprimer_doublons_colonnes(df):
    correspondance_woocommerce = {
        "R√©f√©rence": "SKU",
        "Nom de l'article (en Fran√ßais)": "Name",
        "Description courte (en Fran√ßais)": "Short description",
        "Description (en Fran√ßais)": "Description",
        "Prix pour le groupe D√©faut": "Regular price",
        "Prix de vente conseill√©": "Sale price",
        "Stock - Quantit√©": "Stock",
        "Option Couleur (en Fran√ßais)": "Attribute 1 value(s)",
        "Option Taille (en Fran√ßais)": "Attribute 2 value(s)",
        "Poids (en Kg)": "Weight (kg)",
        "Longueur (en cm)": "Length (cm)",
        "Largeur (en cm)": "Width (cm)",
        "Hauteur (en cm)": "Height (cm)",
        "Cat√©gories": "Categories",
        "Parent": "Parent",
        "Images": "Images",
        "Garantie": "Warranty",
        "Pays de fabrication": "Country of manufacture",
        "Marque": "Brands"
    }
    colonnes_presentes = df.columns
    colonnes_a_supprimer = [
        fr_col for fr_col, en_col in correspondance_woocommerce.items() 
        if fr_col in colonnes_presentes and en_col in colonnes_presentes
    ]
    df.drop(columns=colonnes_a_supprimer, inplace=True, errors='ignore')
    return df

def ajuster_categories(df):
    colonnes_categories = [
        'Nom de la cat√©gorie de niveau 1 (en Fran√ßais)',
        'Nom de la cat√©gorie de niveau 2 (en Fran√ßais)',
        'Nom de la cat√©gorie de niveau 3 (en Fran√ßais)',
        'Nom de la cat√©gorie de niveau 4 (en Fran√ßais)',
    ]
    colonnes_existantes = [col for col in colonnes_categories if col in df.columns]
    if colonnes_existantes:
        df['Categories'] = df[colonnes_existantes].apply(lambda x: ' > '.join(x.dropna()), axis=1)
    if 'Cat√©gorie principale du produit' in df.columns:
        df['Categories'] = df.apply(
            lambda x: f"{x['Categories']} | {x['Cat√©gorie principale du produit']}" 
            if pd.notnull(x['Cat√©gorie principale du produit']) else x['Categories'],
            axis=1
        )
    df.drop(columns=colonnes_existantes + ['Cat√©gorie principale du produit'], inplace=True, errors='ignore')
    return df

def formatter_images(df):
    base_url = "http://yolobaby.online/wp-content/uploads/image-site/"
    colonnes_images = [
        "Image principale",
        "Image suppl√©mentaire n¬∞1",
        "Image suppl√©mentaire n¬∞2",
        "Image suppl√©mentaire n¬∞3",
        "Image suppl√©mentaire n¬∞4",
        "Image suppl√©mentaire n¬∞5",
        "Image suppl√©mentaire n¬∞6",
        "Image suppl√©mentaire n¬∞7",
        "Image suppl√©mentaire n¬∞8",
        "Image suppl√©mentaire n¬∞9"
    ]
    colonnes_existantes = [col for col in colonnes_images if col in df.columns]
    if not colonnes_existantes:
        print("‚ö†Ô∏è Aucune colonne d'image trouv√©e, la colonne 'Images' ne sera pas cr√©√©e.")
        return df
    
    df['Images'] = df[colonnes_existantes].apply(
        lambda row: ", ".join([base_url + img.strip() for img in row.dropna().astype(str)]),
        axis=1
    )
    print("üîç V√©rification des images fusionn√©es avec URLs compl√®tes :")
    print(df[['SKU', 'Images']].head())
    
    if df['Images'].isnull().all():
        print("‚ö†Ô∏è Aucune image fusionn√©e, les colonnes originales ne seront pas supprim√©es.")
    else:
        print("‚úÖ Fusion des images r√©ussie avec URLs, suppression des colonnes d'origine.")
        df.drop(columns=colonnes_existantes, inplace=True, errors='ignore')
    
    return df

############################################
# Fonctions de d√©tection/extraction des couleurs
############################################

def detecter_toutes_couleurs(nom_produit: str):
    if not isinstance(nom_produit, str):
        return []
    
    tokens = re.split(r"[\s\-\|\(\),/]+", nom_produit.lower())
    trouvees = [mapping_couleurs[t] for t in tokens if t in mapping_couleurs]

    return list(dict.fromkeys(trouvees))  # Supprime les doublons

# üìå Fonction pour normaliser une liste de couleurs
def normaliser_liste_couleurs(couleurs_brutes: list):
    if not couleurs_brutes:
        return ""
    return ", ".join(dict.fromkeys([mapping_couleurs.get(c.lower(), "Non sp√©cifi√©e").title() for c in couleurs_brutes]))

# üìå Fonction pour nettoyer le nom du produit en supprimant la couleur
def nettoyer_nom_produit(nom_produit: str, couleurs: list):
    if not isinstance(nom_produit, str):
        return nom_produit
    # On retire d'abord les couleurs (s'il y en a) en tant que mots entiers
    for couleur in couleurs:
        nom_produit = re.sub(rf"\b{couleur}\b", "", nom_produit, flags=re.IGNORECASE)
    # Puis, si le nom contient " - ", on prend uniquement la partie avant
    if " - " in nom_produit:
        nom_produit = nom_produit.split(" - ")[0]
    # Enfin, on nettoie les espaces superflus et d'√©ventuels tirets en fin de cha√Æne
    nom_produit = re.sub(r'[-\s]+$', '', nom_produit)
    return re.sub(r'\s+', ' ', nom_produit).strip()

# üìå Fonction pour d√©tecter les produits composites
def extraire_couleurs_composite(nom_produit: str):
    """
    Extrait les couleurs li√©es aux √©l√©ments "Ch√¢ssis" et "Si√®ge".
    Un produit est consid√©r√© composite s'il a **Ch√¢ssis** et **Si√®ge** dans le m√™me nom.
    """

    if not isinstance(nom_produit, str):
        return {}

    # Normalisation du texte (supprimer accents et mettre en minuscule)
    nom_lower = unicodedata.normalize("NFKD", nom_produit).encode("ASCII", "ignore").decode("utf-8").lower()
    resultat = {}

    # D√©finition des √©l√©ments √† rechercher
    elements_couleur = {
        "Ch√¢ssis": ["ch√¢ssis", "chassis"],
        "Si√®ge": ["si√®ge", "siege", "assise"]
    }

    # V√©rification de la pr√©sence des deux termes dans le m√™me nom de produit
    contient_chassis = any(mot in nom_lower for mot in elements_couleur["Ch√¢ssis"])
    contient_siege = any(mot in nom_lower for mot in elements_couleur["Si√®ge"])

    if not (contient_chassis and contient_siege):
        return {}  # Pas un produit composite

    # D√©finition des adjectifs ignor√©s
    adjectifs_ignores = [
    "light", "pale", "deep", "bright", "medium",
    "fonce", "fonc√©", "clair", "p√¢le", "flashy", "fluorescent",
    "cozy", "mirage", "sepia", "peach", "magic", "canvas", "navy"
    "fog", "stormy", "almond", "leaf", "navy","candy", "fog", "almond", "canvas"
    
    # Ajout des adjectifs li√©s au Ch√¢ssis
    "chrome", "matt", "matt√©", "brillant", "argent√©", "dark", "magic"
    ]

    # Recherche des couleurs pour chaque √©l√©ment
    for nom_element, variantes in elements_couleur.items():
        for variante in variantes:
            # Correction du regex pour √©viter l'erreur "no such group"
            regex_patterns = [
                rf"{variante}\s+(?:({'|'.join(adjectifs_ignores)})\s+)?({'|'.join(couleurs_base)})",
                rf"({'|'.join(couleurs_base)})\s+{variante}"
            ]
            for regex in regex_patterns:
                match = re.search(regex, nom_lower, re.IGNORECASE)
                if match:
                    # V√©rification si l'adjectif est captur√©
                    couleur_brute = match.group(2) if match.lastindex == 2 else match.group(1)
                    couleur_normalisee = mapping_couleurs.get(couleur_brute, couleur_brute).title()
                    resultat[nom_element] = couleur_normalisee
                    break  # Sortir d√®s qu'une couleur est trouv√©e

    return resultat

  # Renvoie un dictionnaire contenant les couleurs d√©tect√©es
def determiner_si_variable(nom_produit: str):
    """
    D√©termine si un produit est variable en fonction du nombre de couleurs d√©tect√©es dans son nom.
    Un produit est variable **s'il contient une seule couleur dans son nom**.
    """
    couleurs_detectees = detecter_toutes_couleurs(nom_produit)
    return len(couleurs_detectees) == 1

# üìå Fonction pour regrouper les produits **variables** par couleur


def regrouper_variations_par_couleur(df):
    """
    Regroupe les produits par mod√®le (bas√© sur le nom nettoy√© sans couleur).

    - Si le groupe ne pr√©sente qu'une seule couleur, le produit est import√© comme produit simple.
    - Sinon, on g√©n√®re :
        ‚Ä¢ Un produit parent (Type = "variable") cr√©√© √† partir du premier produit du groupe.
          Son SKU est modifi√© en ajoutant le pr√©fixe "PARENT-".
          Son nom est nettoy√© (les couleurs et s√©parateurs superflus sont retir√©s).
          Son "Attribute 1 value(s)" contient l'union de toutes les couleurs du groupe.
          Le champ "Code EAN" est vid√© et "Parent SKU" est vide.
        ‚Ä¢ Une ligne variation pour chaque produit du groupe (m√™me celui utilis√© pour le parent).
          Chaque variation conserve son nom complet (avec la couleur) et renseigne "Parent SKU" avec le SKU du parent.
          Pour la variation issue du produit utilis√© pour le parent (qui aurait le m√™me SKU d'origine),
          on modifie son SKU (par exemple en ajoutant un suffixe bas√© sur la couleur) pour garantir l'unicit√©.
    """
    # 1) Regrouper par nom nettoy√© (sans couleur)
    groupes = {}
    for _, row in df.iterrows():
        nom_original = str(row["Name"])
        couleurs_detectees = detecter_toutes_couleurs(nom_original)
        nom_sans_couleur = nettoyer_nom_produit(nom_original, couleurs_detectees).strip()
        key = nom_sans_couleur.lower()
        groupes.setdefault(key, []).append(row)
    
    liste_resultats = []

    # 2) Traiter chaque groupe
    for key, rows in groupes.items():
        # a) Agr√©ger toutes les couleurs du groupe
        couleurs_group = set()
        for row in rows:
            couleurs = detecter_toutes_couleurs(str(row["Name"]))
            couleurs_group.update(couleurs)
        couleurs_group_list = list(couleurs_group)
        
        # Si le groupe ne pr√©sente qu'une seule couleur, importer comme produit simple
        if len(couleurs_group_list) == 1:
            simple_product = rows[0].copy()
            simple_product["Type"] = "simple"
            simple_product["Attribute 1 name"] = "Couleur"
            simple_product["Attribute 1 value(s)"] = normaliser_liste_couleurs(couleurs_group_list)
            simple_product["Attribute 1 visible"] = "yes"
            simple_product["Attribute 1 global"] = "yes"
            simple_product["Parent SKU"] = ""
            # On ne modifie pas le SKU ni le Code EAN pour un produit simple (ou on peut vider l'EAN si souhait√©)
            liste_resultats.append(simple_product)
        else:
            # b) Sinon, cr√©er un produit parent et des variations
            # Cr√©ation du parent √† partir du premier produit du groupe
            parent = rows[0].copy()
            sku_orig = str(parent["SKU"])
            parent["SKU"] = "PARENT-" + sku_orig  # modification du SKU du parent
            # Nettoyer le nom du parent pour retirer la couleur
            parent["Name"] = nettoyer_nom_produit(parent["Name"], detecter_toutes_couleurs(parent["Name"])).strip()
            parent["Type"] = "variable"
            parent["Attribute 1 name"] = "Couleur"
            parent["Attribute 1 value(s)"] = normaliser_liste_couleurs(couleurs_group_list)
            parent["Attribute 1 visible"] = "yes"
            parent["Attribute 1 global"] = "yes"
            # Vider le Code EAN pour le parent
            parent["Code EAN"] = ""
            parent["Parent SKU"] = ""
            liste_resultats.append(parent)
            
            # Cr√©er une variation pour chaque produit du groupe (y compris le premier)
            for row in rows:
                variation = row.copy()
                variation["Type"] = "variation"
                variation["Parent SKU"] = parent["SKU"]
                var_couleurs = detecter_toutes_couleurs(str(variation["Name"]))
                variation["Attribute 1 name"] = "Couleur"
                variation["Attribute 1 value(s)"] = normaliser_liste_couleurs(var_couleurs)
                variation["Attribute 1 visible"] = "yes"
                variation["Attribute 1 global"] = "yes"
                # Si la variation provient du produit utilis√© pour le parent (SKU identique √† l'original),
                # modifier son SKU pour garantir l'unicit√©.
                if str(variation["SKU"]) == sku_orig:
                    if var_couleurs:
                        suffix = var_couleurs[0][:2].upper()  # par exemple "GR" pour "gris"
                    else:
                        suffix = "XX"
                    variation["SKU"] = sku_orig + suffix
                liste_resultats.append(variation)
    
    df_final = pd.DataFrame(liste_resultats)
    return df_final



def main():
    root = Tk()
    root.withdraw()
    
    # üìÇ S√©lection du fichier CSV
    chemin_fichier = filedialog.askopenfilename(
        filetypes=[("CSV Files", "*.csv")],
        title="S√©lectionnez le fichier CSV"
    )
    if not chemin_fichier:
        print("‚ùå Aucun fichier s√©lectionn√©. Fermeture du script.")
        return
    
    try:
        # üìÇ Chargement du fichier avec encodage UTF-8
        df = pd.read_csv(chemin_fichier, encoding="utf-8-sig", dtype=str)
        print(f"üìÇ Fichier charg√© : {os.path.basename(chemin_fichier)}")

        # üõ†Ô∏è Nettoyage des colonnes
        df.columns = df.columns.str.strip()

        # üöÄ V√©rification des colonnes
        print("üîç Colonnes d√©tect√©es :", df.columns.tolist())

        # üõ†Ô∏è Renommer les colonnes pour WooCommerce
        df = renommer_colonnes_pour_woocommerce(df)
        print("‚úÖ Colonnes apr√®s renommage :", df.columns.tolist())

        # üö® V√©rifier si "Name" est bien pr√©sent
        if "Name" not in df.columns:
            raise KeyError(f"‚ùå La colonne 'Name' est absente apr√®s transformation ! Colonnes actuelles : {df.columns.tolist()}")

        # üõ†Ô∏è Suppression des doublons
        df = supprimer_doublons_colonnes(df)
        print("‚úÖ Colonnes apr√®s suppression des doublons :", df.columns.tolist())

        # üõ†Ô∏è Ajustement des cat√©gories
        df = ajuster_categories(df)

        # üñºÔ∏è Formatage des images
        df = formatter_images(df)

        # üöÄ D√©tection des **produits composites**
        df["Composants composites (encod√©s en JSON)"] = df["Name"].apply(extraire_couleurs_composite)
        df["Type"] = df["Composants composites (encod√©s en JSON)"].apply(
            lambda x: "composite" if len(x) > 0 else "variable"
        )

        # ‚úÖ S√©parer les produits **composites** des **variables**
        df_composites = df[df["Type"] == "composite"]
        df_variables = df[df["Type"] == "variable"]

        print(f"üõ†Ô∏è Produits composites d√©tect√©s : {len(df_composites)}")
        print(f"üõ†Ô∏è Produits variables d√©tect√©s : {len(df_variables)}")

        # ‚úÖ D√©tection des produits avec **une seule couleur** pour √™tre variables
        df_variables["Is_Variable"] = df_variables["Name"].apply(determiner_si_variable)

        # ‚úÖ S√©parer les **v√©ritables** produits variables
        df_variables_reels = df_variables[df_variables["Is_Variable"]]

        print(f"‚úÖ Produits variables r√©ellement √©ligibles : {len(df_variables_reels)}")

        # üõ†Ô∏è Regroupement des **produits variables** par couleur
        df_variables_regroupes = regrouper_variations_par_couleur(df_variables_reels)
        print(f"‚úÖ Nombre de produits regroup√©s : {len(df_variables_regroupes)}")

        # üîó Fusion des produits **variables regroup√©s** et **composites**
        df_final = pd.concat([df_composites, df_variables_regroupes], ignore_index=True)

        # üíæ Export du fichier final
        nouveau_chemin = os.path.splitext(chemin_fichier)[0] + "_final.csv"
        df_final.to_csv(nouveau_chemin, index=False, sep=",", encoding="utf-8-sig")
        print(f"‚úÖ Fichier final export√© avec toutes les donn√©es : {nouveau_chemin}")

    except Exception as e:
        print(f"‚ùå Erreur pendant le traitement : {e}")

if __name__ == "__main__":
    main()

